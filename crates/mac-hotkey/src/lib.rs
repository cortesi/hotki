//! Global hotkey registration for macOS.
//!
//! This crate provides a small, focused API to register global hotkeys on
//! macOS and receive key down and key up events. It sets up a
//! CoreGraphics event tap on a dedicated thread and forwards matched hotkey
//! events over a channel for consumption in your application.
//!
//! Notes:
//! - This crate is macOS-only and relies on CoreGraphics/CoreFoundation.
//! - The process typically requires appropriate system permission (e.g.,
//!   Accessibility/Input Monitoring) for key event taps to function.
//! - Modifiers are matched using only SHIFT, CONTROL, ALT, and META; other
//!   modifier bits are ignored for the purposes of hotkey matching.
//! - Interception: when a registration sets [`RegisterOptions::intercept`] to
//!   `true`, matching key down/up (including epeats) are swallowed by the tap
//!   and not delivered to the focused app. While [`Manager::suspend`] is
//!   active, no interception occurs. Some system-reserved shortcuts may not be
//!   interceptable.
//!
#![warn(missing_docs)]
#![warn(unsafe_op_in_unsafe_fn)]
use std::{
    collections::{HashMap, HashSet},
    result::Result as StdResult,
    sync::{Arc, Mutex},
    thread::{self, JoinHandle},
};

use crossbeam_channel::{Receiver, Sender, unbounded};
use thiserror::Error;
use tracing::{debug, trace};

use mac_keycode::{Chord, Key as Code, Modifier};
mod policy;
mod sys;

/// Convenient result type used throughout this crate.
pub type Result<T> = StdResult<T, Error>;

/// Error variants produced by this crate.
#[derive(Error, Debug)]
pub enum Error {
    /// Underlying OS provided an error.
    #[error("OS error: {0}")]
    OsError(String),
    /// Event tap could not be created or initialized.
    #[error("Event tap failed to start")]
    EventTapStart,
    /// Missing or denied system permission
    #[error("Permission denied: {0}")]
    PermissionDenied(&'static str),
    /// No active registration exists for the provided id.
    #[error("Invalid registration id")]
    InvalidId,
}

// Use mac_keycode::Chord directly throughout this crate.

/// The kind of event generated for a matching hotkey.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum EventKind {
    /// The hotkey key was pressed (key down).
    KeyDown,
    /// The hotkey key was released (key up).
    KeyUp,
}

/// An event delivered for a registered hotkey.
#[derive(Clone, Debug)]
pub struct Event {
    /// The registration id returned by [`Manager::register`].
    pub id: u32,
    /// The hotkey that matched the underlying system event.
    pub hotkey: Chord,
    /// The kind of event (down or up).
    pub kind: EventKind,
    /// True if this KeyDown was generated by macOS autorepeat for a held key.
    /// This is always false for KeyUp.
    pub repeat: bool,
}

/// Options controlling hotkey registration behavior.
#[derive(Clone, Copy, Debug, Default)]
pub struct RegisterOptions {
    /// Swallow the underlying system key events for this hotkey.
    ///
    /// When set to `true`, matching key events (both key down and key up)
    /// are intercepted by the event tap and not delivered to
    /// the focused application or other system consumers. In other words, the
    /// keystroke has no effect outside of the events emitted by this crate.
    ///
    /// Notes:
    /// - Interception only applies to events that match a registered hotkey.
    /// - While [`Manager::suspend`] is active, no matching is performed and no
    ///   interception occurs; key events flow to the system as usual.
    /// - Some system-reserved shortcuts may not be interceptable depending on
    ///   OS configuration and permissions.
    pub intercept: bool,
}

#[derive(Clone, Debug)]
struct Registration {
    hotkey: Chord,
    intercept: bool,
}

#[derive(Default)]
struct Inner {
    next_id: u32,
    regs: HashMap<u32, Registration>,
    suspend: usize,
    // Track keys whose KeyDown was intercepted so we can also swallow
    // subsequent repeats and the matching KeyUp even if bindings change.
    held_intercepts: HashSet<Code>,
    // While > 0, capture all keys (swallow non-bound) while HUD is visible
    capture_all: usize,
}

impl Inner {
    fn register(&mut self, hotkey: Chord, opts: RegisterOptions) -> u32 {
        // Simple incrementing id; skip 0 to make it a sentinel if needed
        let id = loop {
            self.next_id = self.next_id.wrapping_add(1);
            if self.next_id == 0 {
                continue;
            }
            if !self.regs.contains_key(&self.next_id) {
                break self.next_id;
            }
        };
        let reg = Registration {
            hotkey,
            intercept: opts.intercept,
        };
        self.regs.insert(id, reg);
        id
    }

    fn unregister(&mut self, id: u32) -> bool {
        self.regs.remove(&id).is_some()
    }

    fn unregister_all(&mut self) -> usize {
        let n = self.regs.len();
        self.regs.clear();
        n
    }

    fn note_intercept_down(&mut self, code: Code) {
        self.held_intercepts.insert(code);
    }

    fn intercept_on_repeat(&self, code: Code) -> bool {
        self.held_intercepts.contains(&code)
    }

    fn intercept_on_keyup(&mut self, code: Code) -> bool {
        self.held_intercepts.remove(&code)
    }
}

#[cfg(test)]
pub(crate) fn test_register(inner: &mut Inner, hotkey: Chord, opts: RegisterOptions) -> u32 {
    inner.register(hotkey, opts)
}

#[derive(Clone)]
struct CallbackCtx {
    inner: Arc<Mutex<Inner>>,
    tx: Sender<Event>,
}

/// Global hotkey manager for macOS.
///
/// A `Manager` runs a background event tap and matches configured hotkeys. It
/// exposes a channel of [`Event`]s for consumption by your application. Dropping
/// a `Manager` gracefully stops its background thread and cleans up the event tap.
pub struct Manager {
    inner: Arc<Mutex<Inner>>,
    rx: Receiver<Event>,
    thread: Option<JoinHandle<()>>,
    sys_ctrl: Arc<sys::SysControl>,
}

impl Manager {
    /// Creates a new manager and initializes the system event tap.
    ///
    /// Returns an error if the event tap cannot be created. This call blocks
    /// until the background thread reports successful initialization.
    pub fn new() -> Result<Self> {
        let inner = Arc::new(Mutex::new(Inner::default()));
        let (tx, rx) = unbounded();
        let ctx = CallbackCtx {
            inner: inner.clone(),
            tx: tx.clone(),
        };

        // One-shot channel to learn if the event tap started successfully.
        let (ready_tx, ready_rx) = crossbeam_channel::bounded(1);

        // Control handle to allow graceful shutdown from the owner thread.
        let sys_ctrl = Arc::new(sys::SysControl::new());

        // Spawn a dedicated thread with its own CFRunLoop for the event tap
        let sys_ctrl_thread = sys_ctrl.clone();
        let handle = thread::spawn(move || {
            // Ignore further errors here; the ready channel communicates the
            // initialization outcome back to the caller.
            let _ = sys::run_event_loop(ctx, ready_tx, sys_ctrl_thread);
        });

        // Block until the background thread reports startup success/failure.
        match ready_rx.recv() {
            Ok(Ok(())) => {
                debug!("mac_hotkey_manager_started");
            }
            Ok(Err(e)) => return Err(e),
            Err(_) => return Err(Error::EventTapStart),
        }

        Ok(Self {
            inner,
            rx,
            thread: Some(handle),
            sys_ctrl,
        })
    }

    /// Test-only constructor: avoid starting the macOS event tap.
    #[cfg(test)]
    pub fn new_test() -> Result<Self> {
        let inner = Arc::new(Mutex::new(Inner::default()));
        let (_tx, rx) = unbounded();
        Ok(Self {
            inner,
            rx,
            thread: None,
            sys_ctrl: Arc::new(sys::SysControl::new()),
        })
    }

    /// Returns a receiver for all matched hotkey events.
    ///
    /// Cloning the receiver follows `crossbeam_channel` semantics: multiple
    /// receivers compete for events rather than receiving broadcast copies.
    pub fn events(&self) -> Receiver<Event> {
        self.rx.clone()
    }

    /// Register a hotkey that is only observed (no interception).
    ///
    /// When a matching event occurs, an [`Event`] is emitted on the channel
    /// returned by [`Manager::events`]. The key events continue to be
    /// delivered to the focused application and the system.
    ///
    /// Use [`Manager::intercept`] to swallow matching events instead.
    pub fn watch(&self, hotkey: Chord) -> u32 {
        let id = self
            .inner
            .lock()
            .unwrap()
            .register(hotkey.clone(), RegisterOptions { intercept: false });
        debug!(id, code = ?hotkey.key, mods = ?hotkey.modifiers, intercept = false, "register_watch");
        id
    }

    /// Register a hotkey that intercepts matching key events.
    ///
    /// When a matching event occurs, an [`Event`] is emitted and the
    /// underlying key events are swallowed by the event tap, preventing
    /// them from reaching the focused application or the OS. This applies
    /// to both KeyDown and KeyUp (including autorepeats).
    ///
    /// Use [`Manager::watch`] to observe events without intercepting.
    pub fn intercept(&self, hotkey: Chord) -> u32 {
        let id = self
            .inner
            .lock()
            .unwrap()
            .register(hotkey.clone(), RegisterOptions { intercept: true });
        debug!(id, code = ?hotkey.key, mods = ?hotkey.modifiers, intercept = true, "register_intercept");
        id
    }

    /// Unregisters a hotkey by id.
    ///
    /// Returns an error if the id does not correspond to an active
    /// registration.
    pub fn unregister(&self, id: u32) -> Result<()> {
        if self.inner.lock().unwrap().unregister(id) {
            debug!(id, "unregister_hotkey");
            Ok(())
        } else {
            Err(Error::InvalidId)
        }
    }

    /// Unregisters all hotkeys.
    ///
    /// Returns the number of registrations that were removed.
    pub fn unregister_all(&self) -> usize {
        let n = self.inner.lock().unwrap().unregister_all();
        if n > 0 {
            debug!(removed = n, "unregister_all");
        }
        n
    }

    /// Temporarily suspends event delivery until the returned guard is dropped.
    ///
    /// Nested guards are supported. While suspended, input is still processed
    /// by the system; only hotkey matching and event delivery are paused.
    pub fn suspend(&self) -> SuspendGuard {
        let inner = self.inner.clone();
        let mut g = inner.lock().unwrap();
        g.suspend = g.suspend.saturating_add(1);
        trace!(count = g.suspend, "suspend");
        drop(g);
        SuspendGuard { inner }
    }

    /// Capture all keys (swallow those not bound) until the returned guard is dropped.
    ///
    /// This is intended to be used while the HUD is visible for a mode that
    /// requests capture semantics. Nested guards are supported.
    pub fn capture_all(&self) -> CaptureGuard {
        let inner = self.inner.clone();
        let mut g = inner.lock().unwrap();
        g.capture_all = g.capture_all.saturating_add(1);
        trace!(count = g.capture_all, "capture_all_on");
        drop(g);
        CaptureGuard { inner }
    }
}

/// A guard which resumes event delivery when dropped.
pub struct SuspendGuard {
    inner: Arc<Mutex<Inner>>,
}

impl Drop for SuspendGuard {
    fn drop(&mut self) {
        if let Ok(mut g) = self.inner.lock()
            && g.suspend > 0
        {
            g.suspend -= 1;
            trace!(count = g.suspend, "resume");
        }
    }
}

/// A guard which disables capture-all when dropped.
pub struct CaptureGuard {
    inner: Arc<Mutex<Inner>>,
}

impl Drop for CaptureGuard {
    fn drop(&mut self) {
        if let Ok(mut g) = self.inner.lock()
            && g.capture_all > 0
        {
            g.capture_all -= 1;
            trace!(count = g.capture_all, "capture_all_off");
        }
    }
}

impl Drop for Manager {
    fn drop(&mut self) {
        // Request the background run loop to stop and join the thread.
        self.sys_ctrl.stop();
        if let Some(h) = self.thread.take() {
            let _ = h.join();
        }
    }
}

#[cfg(test)]
impl Manager {
    fn suspend_count(&self) -> usize {
        self.inner.lock().unwrap().suspend
    }
}

// Matching logic used by the callback, kept testable.
fn match_event(
    inner: &Inner,
    code: Code,
    modifiers: &HashSet<Modifier>,
) -> Option<(u32, Registration)> {
    // Match by exact code and modifiers equality
    // Note: Only consider Command/Control/Option/Shift for matching
    // If multiple registrations exist for the same chord, prefer an intercepting
    // registration to ensure the keystroke is swallowed.
    let mut best: Option<(u32, Registration)> = None;
    let target_mods = normalize_mods(modifiers);
    for (id, reg) in inner.regs.iter() {
        if reg.hotkey.key == code && normalize_mods(&reg.hotkey.modifiers) == target_mods {
            let candidate = (*id, reg.clone());
            match &best {
                None => best = Some(candidate),
                Some((_, breg)) => {
                    if !breg.intercept && reg.intercept {
                        best = Some(candidate);
                    }
                }
            }
        }
    }
    best
}

fn normalize_mods(m: &HashSet<Modifier>) -> HashSet<Modifier> {
    let mut out = HashSet::new();
    if m.contains(&Modifier::Shift) || m.contains(&Modifier::RightShift) {
        out.insert(Modifier::Shift);
    }
    if m.contains(&Modifier::Control) || m.contains(&Modifier::RightControl) {
        out.insert(Modifier::Control);
    }
    if m.contains(&Modifier::Option) || m.contains(&Modifier::RightOption) {
        out.insert(Modifier::Option);
    }
    if m.contains(&Modifier::Command) || m.contains(&Modifier::RightCommand) {
        out.insert(Modifier::Command);
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn registers_and_matches() {
        let mut inner = Inner::default();
        let hk = {
            let mut s = HashSet::new();
            s.insert(Modifier::Control);
            s.insert(Modifier::Option);
            Chord {
                key: Code::H,
                modifiers: s,
            }
        };
        let id = inner.register(hk, RegisterOptions::default());
        assert!(id != 0);
        // extra unrelated bits (ignored modifiers) shouldn't matter
        let mut mods = HashSet::new();
        mods.insert(Modifier::Control);
        mods.insert(Modifier::Option);
        let m = match_event(&inner, Code::H, &mods);
        assert!(m.is_some());
        let (mid, reg) = m.unwrap();
        assert_eq!(mid, id);
        assert_eq!(reg.hotkey.key, Code::H);
    }

    #[test]
    fn unregister_works() {
        let mut inner = Inner::default();
        let hk = {
            let mut s = HashSet::new();
            s.insert(Modifier::Control);
            Chord {
                key: Code::H,
                modifiers: s,
            }
        };
        let id = inner.register(hk, RegisterOptions::default());
        assert!(inner.unregister(id));
        let mut mods = HashSet::new();
        mods.insert(Modifier::Control);
        assert!(match_event(&inner, Code::H, &mods).is_none());
    }

    #[test]
    fn modifiers_are_normalized() {
        let mut inner = Inner::default();
        let hk = {
            let mut s = HashSet::new();
            s.insert(Modifier::Shift);
            s.insert(Modifier::Command);
            Chord {
                key: Code::A,
                modifiers: s,
            }
        };
        let _ = inner.register(hk, RegisterOptions::default());

        // Include unrelated modifiers we ignore; matching should still work
        let mut mods = HashSet::new();
        mods.insert(Modifier::Shift);
        mods.insert(Modifier::Command);
        let got = match_event(&inner, Code::A, &mods);
        assert!(got.is_some());
    }

    #[test]
    fn registration_options_affect_match_output() {
        let mut inner = Inner::default();
        let hk = {
            let mut s = HashSet::new();
            s.insert(Modifier::Control);
            Chord {
                key: Code::B,
                modifiers: s,
            }
        };
        let id = inner.register(hk, RegisterOptions { intercept: true });
        let mut mods = HashSet::new();
        mods.insert(Modifier::Control);
        let m = match_event(&inner, Code::B, &mods).unwrap();
        assert_eq!(m.0, id);
        assert!(m.1.intercept);
    }

    #[test]
    fn suspend_guard_increments_and_decrements() {
        let mgr = Manager::new_test().unwrap();
        assert_eq!(mgr.suspend_count(), 0);
        {
            let _g1 = mgr.suspend();
            assert_eq!(mgr.suspend_count(), 1);
            {
                let _g2 = mgr.suspend();
                assert_eq!(mgr.suspend_count(), 2);
            }
            assert_eq!(mgr.suspend_count(), 1);
        }
        assert_eq!(mgr.suspend_count(), 0);
    }

    #[test]
    fn unregister_all_clears_all_regs() {
        let mut inner = Inner::default();
        let a = {
            let mut s = HashSet::new();
            s.insert(Modifier::Control);
            Chord {
                key: Code::A,
                modifiers: s,
            }
        };
        let b = {
            let mut s = HashSet::new();
            s.insert(Modifier::Option);
            Chord {
                key: Code::B,
                modifiers: s,
            }
        };
        let _ = inner.register(a, RegisterOptions::default());
        let _ = inner.register(b, RegisterOptions::default());
        let mut mods = HashSet::new();
        mods.insert(Modifier::Control);
        assert!(match_event(&inner, Code::A, &mods).is_some());
        mods.clear();
        mods.insert(Modifier::Option);
        assert!(match_event(&inner, Code::B, &mods).is_some());
        let removed = inner.unregister_all();
        assert_eq!(removed, 2);
        let mut mods2 = HashSet::new();
        mods2.insert(Modifier::Control);
        assert!(match_event(&inner, Code::A, &mods2).is_none());
        mods2.clear();
        mods2.insert(Modifier::Option);
        assert!(match_event(&inner, Code::B, &mods2).is_none());
    }

    #[test]
    fn unregister_invalid_id_returns_error() {
        let mgr = Manager::new_test().unwrap();
        let res = mgr.unregister(123_456); // arbitrary unused id
        assert!(res.is_err());
        if let Err(Error::InvalidId) = res {
            // expected
        } else {
            panic!("expected InvalidId error");
        }
    }
}
